# Add the packages we would like to import from to the path
import sys
sys.path.append('../../../../packages/kernel-density-estimator-bandwdidth-prediction/packages/')
sys.path.append('../../../')


import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
from matplotlib.legend_handler import HandlerPatch
import numpy as np
import seaborn as sns
import os
import torch
import pandas as pd
import copy
import yaml



# The bandwidth stuff
from kernel_density_estimation.kernel_density_estimator import *
from models.particle_transformer import *
from datasets.deepmind_maze_dataset import *
from problems.deepmind_maze.deepmind_maze_problem import *


def find_median_run_index(experiment, maze_number, number_of_runs=5, metric="nll"):

    # The data for this experiment
    data = []

    for i in range(number_of_runs):

        results_filepath = "experiments/deepmind_maze_experiments_multiple_runs/{}/saves/run_{:03d}/full_dpf_evaluation_maze_{:d}/table_results.pt".format(experiment, i, maze_number)

        # Check if the file exists, if it doesnt then skip this file
        if(os.path.isfile(results_filepath) == False):
            assert(False)

        # Load the data 
        results = torch.load(results_filepath)  

        # Extract the NLL
        nll_mean = results[metric][0]

        # Save the data
        data.append(nll_mean)


    # Sort so we can extract the median
    sorted_data = copy.copy(data)
    sorted_data = sorted(sorted_data)

    # Extract the median
    median_value = sorted_data[number_of_runs//2]

    # Get the median index
    for i in range(number_of_runs):
        if(data[i] == median_value):
            return i

    assert(False)


def load_sequence_data(experiment, run_number, maze_number):
    filepath = "experiments/deepmind_maze_experiments_multiple_runs/{}/saves/run_{:03d}/full_dpf_evaluation_maze_{:d}/raw_all_sequence_evaluation_run_data.pt".format(experiment, run_number, maze_number)

    # Check if the file exists, if it doesnt then skip this file
    if(os.path.isfile(filepath) == False):
        return None

    # Load the data 
    data = torch.load(filepath)  

    return data



def load_dataset(maze_number):

    # Load the dataset parameters
    with open("./experiments/deepmind_maze_experiments_multiple_runs/config_files/dataset_params_evaluation_maze_{:d}.yaml".format(maze_number)) as file:

        # Load the whole file into a dictionary
        doc = yaml.load(file, Loader=yaml.FullLoader)

        # Load the dataset
        dataset = DeepMindMazeDataset(doc["dataset_params"], "evaluation")
        return dataset





def render_maze(ax, dataset, maze_number):

    # Compute the maze ID
    maze_id = maze_number - 1

    # Set the X and Y limits
    ax.set_xlim(dataset.get_x_range_scaled(maze_id))
    ax.set_ylim(dataset.get_y_range_scaled(maze_id))

    # Draw the walls
    walls = dataset.get_walls(maze_id)
    walls = dataset.scale_data_down(walls, maze_id)
    ax.plot(walls[:, :, 0].T, walls[:, :, 1].T, color="black", linewidth=3)



def main():


    maze_numbers = [1]
    sequences_to_render = dict()
    # sequences_to_render[1] = 0 # pretty ok
    sequences_to_render[1] = 1 # pretty ok

    length_of_rendered_path = 25

    # We need the transformers
    particle_transformer = DeepMindTransformer()

    # Plot!!!!!
    rows = 1
    cols = len(maze_numbers)
    fig, axes = plt.subplots(rows, cols, sharex=True, figsize=(3*cols, 3*rows), squeeze=False)

    for m_idx, maze_number in enumerate(maze_numbers):

        # Get which sequence to render
        sequence_to_render = sequences_to_render[maze_number]

        # Get the axis for this maze
        ax = axes[0, m_idx]

        # Turn off the axis
        # ax.axis('off')


        # Change directories to make everything very easy 
        absolute_path = os.path.dirname(os.path.realpath(__file__))
        os.chdir("../../..")


        # The experiments we want to load and the order we want them to be rendered in
        experiments = []
        experiments.append("experiment0003_importance_init")
        # experiments.append("experiment0001")
        # experiments.append("experiment0003_importance_init")
        # experiments.append("experiment0003_importance_init")

        # Load the dataset
        dataset = load_dataset(maze_number)

        # Render the maze
        render_maze(ax, dataset, maze_number)


        # Get the data for this sequence 
        true_sequence_data = dataset[sequence_to_render]
        true_states = true_sequence_data["states"]

        # Draw the true path
        x1 = true_states[:length_of_rendered_path, 0].numpy()
        y1 = true_states[:length_of_rendered_path, 1].numpy()
        ax.plot(x1, y1, color="red", marker="o", label="True Path", linewidth=4)


        # Render for each sequence
        for i, experiment in enumerate(tqdm(experiments, desc="Experiment")):

            # Get which run to load
            median_run_idx = find_median_run_index(experiment, maze_number)

            # Load the run data
            run_data = load_sequence_data(experiment, median_run_idx, maze_number)

            # Get this particular sequence
            sequence_data = run_data[sequence_to_render]
            particles = sequence_data["particles"]
            particle_weights = sequence_data["particle_weights"]

            # Compute the mean particle
            particles = particle_transformer.backward_tranform(particles)
            predicted_state = torch.sum(particles * particle_weights.unsqueeze(-1), dim=1)
            predicted_state = particle_transformer.forward_tranform(predicted_state)

            # Draw the Predicted path
            x1 = predicted_state[:length_of_rendered_path, 0].detach().cpu().numpy()
            y1 = predicted_state[:length_of_rendered_path, 1].detach().cpu().numpy()
            ax.plot(x1, y1, color="green", label="PF Path", linewidth=4)

        # Go back to the right spot
        os.chdir(absolute_path)

    # Adjust whitespace
    fig.subplots_adjust(wspace=0.01, hspace=0.03)
    fig.tight_layout(rect=(0,0,1,0.96))

    plt.show()

if __name__ == '__main__':
    main()


