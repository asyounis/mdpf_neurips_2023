import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns
import os
import torch




def load_data_for_experiment(experiment, maze_number, number_of_runs=5, metric="nll"):

    # The data for this experiment
    data = []

    for i in range(number_of_runs):

        if(metric == "nll"):
            # The file we want to load
            results_filepath = "../../../experiments/deepmind_maze_experiments_multiple_runs/{}/saves/run_{:03d}/full_dpf_evaluation_maze_{:d}/table_results.pt".format(experiment, i, maze_number)
        elif(metric == "rmse"):
            results_filepath = "../../../experiments/deepmind_maze_experiments_multiple_runs/{}/saves/run_{:03d}/full_dpf_evaluation_maze_{:d}_mse/table_results.pt".format(experiment, i, maze_number)
        else:
            assert(False)

        # Check if the file exists, if it doesnt then skip this file
        if(os.path.isfile(results_filepath) == False):
            return None

        # Load the data 
        results = torch.load(results_filepath)  

        # Extract the NLL
        nll_mean = results[metric][0]

        # Save the data
        data.append(nll_mean)

    return data


def load_data(experiments, maze_number, metric):

    # All the data we loaded
    all_data = []

    # The experiments we actually loaded
    experiments_loaded = []

    # Fake the data for now
    for experiment in experiments:

        # Load the experiment data
        experiment_data = load_data_for_experiment(experiment, maze_number, metric=metric)

        # Skip if we dont have data
        if(experiment_data is None):
            continue

        # Save the experiment data
        all_data.append(experiment_data)
        experiments_loaded.append(experiment)

    all_data = np.asarray(all_data)
    all_data = np.transpose(all_data)

    return all_data, experiments_loaded


def generate_labels(experiments):

    # The names we want to give to the experiments
    experiment_names = dict()
    experiment_names["lstm_rnn"] = "LSTM"
    # experiment_names["diffy_particle_filter"] = "TG-PF"
    # experiment_names["optimal_transport_pf"] = "OT-PF"
    # experiment_names["soft_resampling_particle_filter"] = "SR-PF"
    # experiment_names["importance_sampling_pf"] = "DIS-PF"

    experiment_names["experiment0001"] = "TG-MDPF"
    experiment_names["experiment0002_importance"] = "MDPF"
    # experiment_names["experiment0003_importance"] = "A-MDPF"
    # experiment_names["experiment0003_importance_init"] = "A-MDPF-Init"
    experiment_names["experiment0003_importance_init"] = "A-MDPF"


    experiment_names["experiment0002_implicit"] = "MDPF-Implicit"
    experiment_names["experiment0003_implicit"] = "A-MDPF-Implicit"

    experiment_names["experiment0002_concrete"] = "MDPF-Concrete"
    experiment_names["experiment0003_concrete"] = "A-MDPF-Concrete"


    experiment_names["diffy_particle_filter_learned_band"] = "TG-PF"
    experiment_names["optimal_transport_pf_learned_band"] = "OT-PF"
    experiment_names["soft_resampling_particle_filter_learned_band"] = "SR-PF"
    experiment_names["importance_sampling_pf_learned_band"] = "DIS-PF"

    # Generate the label names in the correct order
    labels = [experiment_names[e] for e in experiments]

    return labels




def main():
	
    # The experiments we want to load and the order we want them to be rendered in
    experiments = []
    # experiments.append("diffy_particle_filter")
    # experiments.append("optimal_transport_pf")
    # experiments.append("soft_resampling_particle_filter")
    # experiments.append("importance_sampling_pf")
    experiments.append("diffy_particle_filter_learned_band")
    experiments.append("optimal_transport_pf_learned_band")
    experiments.append("soft_resampling_particle_filter_learned_band")
    experiments.append("importance_sampling_pf_learned_band")
    experiments.append("experiment0002_concrete")
    experiments.append("experiment0003_concrete")
    experiments.append("experiment0001")
    experiments.append("experiment0002_importance")
    # experiments.append("experiment0003_importance")
    experiments.append("experiment0003_importance_init")


    metrics = []
    metrics.append(("nll", "Negative Log-likelihood"))
    metrics.append(("rmse", "Root-Mean-Square-Error"))


    maze_numbers = [1]
    for maze_number in maze_numbers:


        for metric in metrics:

            metric_code_name = metric[0]
            metric_name = metric[1]

            # Load the data
            data, experiments_loaded = load_data(experiments, maze_number, metric_code_name)

            # Plot!!!!!
            rows = 1
            cols = 1
            fig, axes = plt.subplots(rows, cols, sharex=True, figsize=(14, 6), squeeze=False)

            # Get the axis to plot on
            ax = axes[0,0]

            # Plot.  
            # 	Note: set "whis" to a large number to prevent outliers from being rendered as diamonds, keep them in the min and max whiskers of the box plot
            sns.boxplot(data=data, ax=ax, color=sns.color_palette(as_cmap=True)[3], medianprops={"color": "red"}, boxprops={"facecolor": (.4, .6, .8, .5)}, whis=1000000)

            # Generate the labels
            labels = generate_labels(experiments_loaded)

            # Locations of the labels
            x = np.arange(len(labels))
            ax.set_xticks(x, labels, rotation=0, fontsize=10, ha="center",va="top")

            ax.set_title(metric_name, fontsize=14)
            ax.set_xlabel("Method",fontsize=14)
            ax.set_ylabel(metric_name,fontsize=14)


            # Make sure the labels are inside the image
            fig.tight_layout()

            # Save
            plt.savefig("maze_{:d}_box_plot_{}.png".format(maze_number, metric_code_name))
            plt.savefig("maze_{:d}_box_plot_{}.pdf".format(maze_number, metric_code_name))




    # maze_numbers = [1, 1]
    # for metric in metrics:

    #     all_data = []

    #     for maze_number in maze_numbers:



    #         metric_code_name = metric[0]
    #         metric_name = metric[1]

    #         # Load the data
    #         data, experiments_loaded = load_data(experiments, maze_number, metric_code_name)
    #         # all_data.append(data)

            

    #         print(data.shape)

    #         exit()

    #     # df = sns.load_dataset("titanic")
    #     # print(df)

    #     exit()


    #     data = all_data

    #     # Plot!!!!!
    #     rows = 1
    #     cols = 1
    #     fig, axes = plt.subplots(rows, cols, sharex=True, figsize=(14, 6), squeeze=False)

    #     # Get the axis to plot on
    #     ax = axes[0,0]

    #     # Plot.  
    #     #     Note: set "whis" to a large number to prevent outliers from being rendered as diamonds, keep them in the min and max whiskers of the box plot
    #     sns.boxplot(data=data,x=["k"], ax=ax, color=sns.color_palette(as_cmap=True)[3], medianprops={"color": "red"}, boxprops={"facecolor": (.4, .6, .8, .5)}, whis=1000000)

    #     # Generate the labels
    #     labels = generate_labels(experiments_loaded)

    #     # Locations of the labels
    #     x = np.arange(len(labels))
    #     ax.set_xticks(x, labels, rotation=0, fontsize=10, ha="center",va="top")

    #     ax.set_title(metric_name, fontsize=14)
    #     ax.set_xlabel("Method",fontsize=14)
    #     ax.set_ylabel(metric_name,fontsize=14)


    #     # Make sure the labels are inside the image
    #     fig.tight_layout()

    #     # Save
    #     plt.savefig("maze_{:d}_box_plot_{}.png".format(maze_number, metric_code_name))
    #     plt.savefig("maze_{:d}_box_plot_{}.pdf".format(maze_number, metric_code_name))




if __name__ == '__main__':
	main()